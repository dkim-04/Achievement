# 문제

## 1번
n 개의 원소와 q 개의 질의가 주어집니다.

하나의 질의는 다음 세 종류 중 하나입니다:

"1 a"
a번째 원소를 출력합니다.
"2 b"
n 개의 원소 중에 값이 b인 원소를 찾아, 그 원소가 몇 번째 원소인지 출력합니다.
그러한 원소가 여러 개라면, 그 중에서 index가 제일 작은 원소의 것을 출력합니다.
그러한 원소가 없다면, 0을 출력합니다.
"3 s e"
s번째 원소부터 e번째 원소까지 각 원소의 값을 공백으로 구분하여 차례대로 출력합니다.
각 질의를 차례대로 수행하는 프로그램을 작성해보세요.

입력 형식
첫 줄에 두 정수 n과 q가 주어집니다.

그다음 줄에 n 개의 원소의 값이 차례대로 공백으로 구분되어 주어집니다.

그다음 줄부터 q개의 줄에 걸쳐 질의가 주어집니다. 각 질의는 다음 3개 중 하나의 타입으로 주어집니다.

"1 a"
"2 b"
"3 s e"
1≤n≤100
1≤q≤100
n 개의 원소의 값은 모두 1 이상 100 이하입니다.
1≤a≤n
1≤b≤100
1≤s≤e≤n
출력 형식
첫 줄부터 q 개의 줄에 걸쳐, q 개의 질의에 대한 결과를 한 줄에 하나씩 차례대로 출력합니다.

입출력 예제
예제1
입력:

3 3 

1 8 5

1 1

2 5

3 1 2

출력:

1

3

1 8

hint
문제에서 주어지는 입력을 한번에 받지 않고
질의마다 입력 받고, 출력 하는 것을 반복하여도 올바른 출력 결과가 나온다면 맞는 코드입니다.
```
n,q=map(int,input().split()) # n 원소 개수,q:질의 개수
nn=list(map(int,input().split())) # n개의 원소 리스트 

for i in range(q): # q개의 질의 반복
    qq=list(map(int,input().split()))
    que=qq[0] # 1번 답번: a번째 원소
    if que==1:
        print(nn[qq[1]-1])
    elif que==2: # 2번 답변
        for j in range(n):
            if nn[j]==qq[1]:
                print(j+1)
                break
        else:
            print(0)

    else:
        for j in range(qq[1], qq[2]+1):
            print(nn[j-1],end=' ')
        print()
```

## 2번
n1개의 원소로 이루어져 있는 수열 A의 정보와, n2개의 원소로 이루어져 있는 수열 B의 정보가 주어졌을 때 수열 B가 수열 A의 연속부분수열인지를 판단하는 프로그램을 작성해보세요.

수열 B가 수열 A의 원소들을 연속하게 뽑았을 때 나올 수 있는 수열이라면 연속부분수열이라 부릅니다.

예를 들어 수열 A가 [1, 5, 2, 6] 일때 수열 B가 [5, 2]라면 수열 B는 수열 A의 연속 부분 수열이지만, 만약 수열 B가 [5, 6]이라면 연속 부분 수열이 아닙니다.

입력 형식
첫 번째 줄에 수열 A의 원소의 개수를 나타내는 n1과 수열 B의 원소의 개수를 나타내는 n2값이 각각 공백을 사이에 두고 주어집니다.

두 번째 줄에는 수열 A에 해당하는 n1개의 원소가 공백을 사이에 두고 주어집니다.

세 번째 줄에는 수열 B에 해당하는 n2개의 원소가 공백을 사이에 두고 주어집니다.

1 ≤ n1, n2 ≤ 100
1 ≤ 주어지는 원소 ≤ 100
출력 형식
수열 B가 수열 A의 연속부분수열이라면 Yes, 아니라면 No를 출력합니다.

입출력 예제
예제1
입력:

4 2
1 5 2 6
5 6
출력:

No
```
n1, n2 = map(int, input().split())  # A 원소 개수와 B 원소의 개수
A = list(map(int, input().split()))  # A 리스트 입력
B = list(map(int, input().split()))  # B 리스트 입력

found = False  # B 리스트가 A 안에 존재하는지 여부

for i in range(n1 - n2 + 1):  # A에서 B의 길이만큼 확인
    if B[0] == A[i]:  # 첫 번째 원소가 일치하는 경우
        match = True  # 일치 여부를 추적
        for j in range(1, n2):  # B의 나머지 원소들과 비교
            if B[j] != A[i + j]:  # 일치하지 않는 경우
                match = False
                break  # 더 이상 비교할 필요 없음
        if match:  # 만약 모든 원소가 일치하면
            found = True
            break  # 일치하는 부분을 찾았으므로 반복 종료

if found:
    print('Yes')  # B 리스트가 A에 존재함
else:
    print('No')   # B 리스트가 A에 존재하지 않음
```
